/**
 * Vancouver Master Import - ALL 187 SCRAPERS
 */

const { MongoClient } = require('mongodb');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs');
const path = require('path');
const { getVenueAddress } = require('../scrapers/utils/venueAddresses');
// Image blacklist - filter out generic venue logos and placeholders
const IMAGE_BLACKLIST = [
  'logo', 'default', 'placeholder', 'brand', 'favicon', 'icon',
  'social', 'share', 'og-image', 'twitter', 'facebook',
  '1x1', 'spacer', 'pixel', 'tracking', 'blank',
  'venue-logo', 'venue_logo', 'venue-default',
  'generic', 'template', 'sample', 'test', 'missing'
];
function isGenericImage(imageUrl) {
  if (!imageUrl) return true;
  const lower = imageUrl.toLowerCase();
  return IMAGE_BLACKLIST.some(p => lower.includes(p));
}
const MONGODB_URI = 'mongodb+srv://discovr123:discovr1234@discovr.vzlnmqb.mongodb.net/?retryWrites=true&w=majority&appName=Discovr';
async function importAllVancouverEvents() {
  const cityName = 'Vancouver';
  const provinceCode = 'BC';
  console.log('üöÄ Starting Vancouver COMPLETE import (ALL scrapers with date normalization)...');
  
  const client = new MongoClient(MONGODB_URI);
  try {
    await client.connect();
    console.log('‚úÖ Connected to MongoDB');
    
    const db = client.db('discovr');
    const collection = db.collection('events');
    // PRESERVE CLICK COUNTS before deleting
    console.log('üìä Saving click counts before clearing events...');
    const existingEvents = await collection.find({ 
      city: cityName, 
      source: { $ne: 'admin' },
      clickCount: { $gt: 0 }
    }).toArray();
    const clickCountMap = new Map();
    for (const event of existingEvents) {
      const key = `${(event.title || '').toLowerCase().trim()}|${(event.venue?.name || '').toLowerCase().trim()}`;
      clickCountMap.set(key, event.clickCount);
    }
    console.log(`üíæ Saved ${clickCountMap.size} click counts to preserve`);
    // Clear existing Vancouver events BUT preserve admin-created events
    console.log('üßπ Clearing existing Vancouver events (preserving admin-created)...');
    const deleteResult = await collection.deleteMany({ 
      city: cityName,
      source: { $ne: 'admin' }  // Don't delete admin-created events
    });
    console.log(`üóëÔ∏è Removed ${deleteResult.deletedCount} scraped events (admin events preserved)`);
    // Use the new Vancouver index.js which handles date normalization
    console.log('üìç Loading Vancouver scrapers via index.js (with date normalization)...');
    const vancouverScraper = require('../scrapers/cities/vancouver/index.js');
    // Run all Vancouver scrapers through the coordinator (dates already normalized to ISO)
    const events = await vancouverScraper.scrape();
    let allEvents = [];
    if (events && events.length > 0) {
      const processedEvents = events.map(event => {
        // Date is already normalized to ISO format by index.js
        let dateRange = null;
        
        if (event.date) {
          try {
            // CRITICAL FIX: Parse ISO date in VANCOUVER timezone (America/Vancouver - PST/PDT)
            let parsedDate;
            const isoMatch = event.date.match(/^(\d{4})-(\d{2})-(\d{2})$/);
            if (isoMatch) {
              const year = parseInt(isoMatch[1]);
              const month = parseInt(isoMatch[2]) - 1;
              const day = parseInt(isoMatch[3]);
              const dateStr = `${isoMatch[1]}-${isoMatch[2]}-${isoMatch[3]}T12:00:00`;
              // Vancouver: PST = -08:00, PDT = -07:00
              const tempDate = new Date(year, month, day, 12, 0, 0);
              const isDST = tempDate.getTimezoneOffset() < new Date(year, 0, 1).getTimezoneOffset();
              parsedDate = new Date(dateStr + (isDST ? '-07:00' : '-08:00'));
            } else {
              parsedDate = new Date(event.date);
            }
            
            // Check if date is valid
            if (isNaN(parsedDate.getTime())) {
              console.log(`   ‚ö†Ô∏è Skipping event with invalid date: "${event.date}" - ${event.title}`);
              return null;
            }
            dateRange = {
              start: parsedDate,
              end: parsedDate
            };
          } catch (err) {
            console.log(`   ‚ö†Ô∏è Skipping event with bad date: "${event.date}" - ${event.title}`);
            return null;
          }
        } else {
          // Skip events with no date
          console.log(`   ‚ö†Ô∏è Skipping event with no date: ${event.title}`);
          return null;
        }
        // Normalize venue to object format required by Event model
        // CRITICAL FIX: Use venue address from scraper first
        let venueName = 'Unknown Venue';
        let venueAddress = '';
        if (event.venue) {
          if (typeof event.venue === 'string') {
            venueName = event.venue;
          } else {
            venueName = event.venue.name || 'Unknown Venue';
            venueAddress = event.venue.address || '';
        if (!venueAddress || venueAddress === cityName) {
          venueAddress = getVenueAddress(venueName, cityName);
        const venueObj = { 
          name: venueName, 
          address: venueAddress, 
          city: cityName 
        };
        // Filter out generic images
        let eventImage = event.image || event.imageUrl || null;
        if (eventImage && isGenericImage(eventImage)) {
          eventImage = null;
        // RESTORE CLICK COUNT if this event existed before
        const clickKey = `${(event.title || '').toLowerCase().trim()}|${(venueObj.name || '').toLowerCase().trim()}`;
        const preservedClickCount = clickCountMap.get(clickKey) || 0;
        return {
          ...event,
          id: event.id || uuidv4(),
          title: event.title,  // CRITICAL: server.js requires title field
          startDate: dateRange.start,  // CRITICAL: server.js requires startDate field
          endDate: dateRange.end,      // Also add endDate for compatibility
          dateRange,
          image: eventImage,
          imageUrl: eventImage,
          url: event.url,  // Include URL for website link
          sourceURL: event.url,  // Also set sourceURL for compatibility
          venue: venueObj,
          city: cityName,
          province: provinceCode,
          country: 'Canada',
          clickCount: preservedClickCount  // PRESERVE CLICK COUNT
      }).filter(e => e !== null);  // Remove null events
      
      allEvents = processedEvents;
      console.log(`   ‚úÖ ${processedEvents.length} valid events (skipped ${events.length - processedEvents.length} with bad/missing dates)`);
    } else {
      console.log(`   ‚ö†Ô∏è 0 events from all scrapers`);
    if (allEvents.length > 0) {
      console.log(`üìä Collected ${allEvents.length} total events from all scrapers`);
      console.log(`üîÑ Deduplicating events...`);
      // Deduplicate events based on title + date + venue
      const uniqueEvents = new Map();
      let duplicateCount = 0;
      for (const event of allEvents) {
        const titleNorm = (event.title || '').toLowerCase().trim().replace(/\s+/g, ' ');
        const dateStr = event.dateRange?.start ? new Date(event.dateRange.start).toISOString().split('T')[0] : '';
        const locationNorm = (event.venue?.name || event.location || '').toLowerCase().trim();
        const uniqueKey = `${titleNorm}|${dateStr}|${locationNorm}`;
        if (!uniqueEvents.has(uniqueKey)) {
          uniqueEvents.set(uniqueKey, event);
          duplicateCount++;
      }
      const deduplicatedEvents = Array.from(uniqueEvents.values());
      console.log(`‚ú® Removed ${duplicateCount} duplicates`);
      console.log(`üíæ Upserting ${deduplicatedEvents.length} events...`);
      let inserted = 0, updated = 0;
      for (const event of deduplicatedEvents) {
        const result = await collection.updateOne(
          { title: event.title, 'venue.name': event.venue?.name },
          { $set: event },
          { upsert: true }
        );
        if (result.upsertedCount > 0) inserted++;
        else if (result.modifiedCount > 0) updated++;
      console.log('\nüìä VANCOUVER COMPLETE IMPORT SUMMARY:');
      console.log(`üéâ Inserted ${inserted} new, updated ${updated} existing`);
      console.log(`‚úÖ All events have normalized ISO dates (YYYY-MM-DD)`);
      console.log('‚ö†Ô∏è No events found across all scrapers');
  } catch (error) {
    console.error('‚ùå Import error:', error.message);
  } finally {
    await client.close();
    console.log('üîå Database connection closed');
  }
importAllVancouverEvents().catch(console.error);
