const { getCityFromArgs } = require('../../utils/city-util.js');

  parseEventElement($, el) {
    try {
      // On the new website structure, each event is an <a> tag
      // The href links to the event detail page
      const link = $(el).attr('href') || '';
      if (!link) return null;

      // Get the full URL if it's relative
      const eventUrl = link.startsWith('http') ? link : `${this.baseUrl}${link}`;

      let title = '';
      // Only store date, not time as per requirement
      let date = new Date();
      date.setHours(0, 0, 0, 0); // Reset time to start of day

      // For TicketWeb links, use better parsing
      if (eventUrl.includes('ticketweb.ca/event/')) {
        // Extract real title from TicketWeb URL
        // Format is usually: https://www.ticketweb.ca/event/ARTIST-NAME-venue-name-tickets/12345
        const ticketWebPath = new URL(eventUrl).pathname;
        const pathParts = ticketWebPath.split('/');

        if (pathParts.length >= 3) {
          // The event name is usually the part after /event/
          const eventPart = pathParts[2];

          // Extract artist name before the venue
          if (eventPart.toLowerCase().includes('fortune-sound-club')) {
            const artistPart = eventPart.split('-fortune-sound-club')[0];
            title = artistPart.replace(/-/g, ' ').trim();
            title = title.replace(/\b\w/g, l => l.toUpperCase()); // Capitalize first letter of each word
          } else {
            title = eventPart.replace(/-/g, ' ').trim();
            title = title.replace(/\b\w/g, l => l.toUpperCase());
          }
        }

        // Try to extract the date from other elements near this link
        // Look at parent containers, siblings, etc.
        const parentDiv = $(el).parent();
        const grandparentDiv = parentDiv.parent();

        // Common date formats we might find in text
        const dateRegex = /([A-Za-z]+\s\d{1,2}(st|nd|rd|th)?,?\s\d{4})|(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/;

        // Search in multiple locations
        const searchTexts = [
          $(parentDiv).text(),
          $(grandparentDiv).text(),
          $(el).text()
        ];

        // Try to find a date
        for (const text of searchTexts) {
          const match = text.match(dateRegex);
          if (match && match[0]) {
            const parsedDate = new Date(match[0]);
            // Verify it's a valid date
            if (!isNaN(parsedDate.getTime())) {
              date = parsedDate;
              date.setHours(0, 0, 0, 0); // No specific time, only date
              break;
            }
          }
        }
      } else {
        // For non-TicketWeb links, use the regular parsing
        const pathParts = link.split('/');
        const slug = pathParts[pathParts.length - 1];
        title = slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      }

      // Skip if we don't have essential details
      if (!title || title.length < 2) return null;

      return {
        title,
        description: `Event at ${this.name}`,
        startDate: date,
        image: '',
        sourceURL: eventUrl,
        officialWebsite: eventUrl,
        ticketURL: eventUrl,
        categories: ['Music', 'Nightlife']
      };
    } catch (error) {
      console.error('Error parsing event element:', error);
      return null;
    }
  }

  /**
   * Format event to match Discovr API schema
   * @param {Object} event - Raw event data
   * @returns {Object} - Formatted event
   */
  formatEvent(event) {
    // Generate deterministic ID
    const idSource = `${event.title}-${this.venue.name}-${event.startDate?.toISOString() || new Date().toISOString()}`;
    const id = uuidv5(idSource, NAMESPACE);

    // Format start date
    const startDate = event.startDate || new Date();

    return {
      id,
      title: event.title,
      name: event.title,
      description: event.description || `Event at ${this.venue.name}`,
      image: event.image || '',
      date: startDate.toISOString(),
      startDate,
      endDate: null, // Fortune Sound Club doesn't provide end dates
      season: this.determineSeason(startDate),
      category: event.categories?.[0] || 'Nightlife',
      categories: event.categories || ['Music', 'Nightlife'],
      location: this.venue.name,
      venue: this.venue,
      sourceURL: event.sourceURL || thissUrl,
      officialWebsite: event.officialWebsite || this.baseUrl,
      ticketURL: event.ticketURL || '',
      dataSources: [`vancouver-${this.sourceIdentifier}`],
      lastUpdated: new Date()
    };
  }

  /**
   * Parse date string into Date object
   * @param {string} da - Date string
   * @returns {Date|null} - Parsed date or current date if parsing fails
   */
  parseDate(da) {
    try {
      if (!da) return new Date();

      const date = new Date(da);

      // Check if date is valid
      if (isNaN(date.getTime())) {
        console.warn(`Invalid date: ${da}, using current date`);
        return new Date();
      }

      return date;
    } catch (error) {
      console.warn(`Error parsing date "${da}":`, error.message);
      return new Date();
    }
  }

  /**
   * Determine season based on date
   * @param {Date} date - Event date
   * @returns {string} - Season name
   */
  determineSeason(date) {
    const month = date.getMonth();

    if (month >= 2 && month <= 4) return 'Spring';
    if (month >= 5 && month <= 7) return 'Summer';
    if (month >= 8 && month <= 10) return 'Fall';
    return 'Winter';
  }
}

// Export a single instance of the scraper
module.exports = new FortuneSoundClubScraper();

// Function export for compatibility with runner/validator
module.exports = async (city) => {
  const scraper = new FortuneSoundClubScraper();
  return await scraper.scrape(city);
};

// Also export the class for backward compatibility
module.exports.FortuneSoundClubScraper = FortuneSoundClubScraper;
