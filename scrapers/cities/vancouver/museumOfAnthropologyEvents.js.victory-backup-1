const { getCityFromArgs } = require('../../utils/city-util.js');

  determineCategories(title, description) {
    const text = `${title} ${description}`.toLowerCase();
    const categories = ['arts', 'museum', 'cultural'];

    if (text.includes('exhibition') || text.includes('exhibit')) {
      categories.push('exhibition');
    }

    if (text.includes('workshop') || text.includes('class')) {
      categories.push('workshop');
    }

    if (text.includes('tour') || text.includes('guided')) {
      categories.push('tour');
    }

    if (text.includes('family') || text.includes('kid') || text.includes('child')) {
      categories.push('family');
    }

    if (text.includes('lecture') || text.includes('talk') || text.includes('panel')) {
      categories.push('talk');
    }

    if (text.includes('indigenous') || text.includes('first nations') || text.includes('aboriginal')) {
      categories.push('indigenous');
    }

    return categories;
  }

  /**
   * Main scraping function to extract events
   * @returns {Promise<Array>} - Array of event objects
   */
  async scrape() {
    if (!this.enabled) {
      console.log(`${this.name} scraper is disabled`);
      return [];
    }

    console.log(`ðŸ” Scraping events from ${this.name}...`);
    const events = [];
    let browser;

    try {
      // Launch Puppeteer browser
      browser = await puppeteer.launch({
        headless: 'new',
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--ignore-certificate-errors',
          '--disable-features=IsolateOrigins',
          '--disable-site-isolation-trials'
        ]
      });

      const page = await browser.newPage();

      // Set viewport and user agent
      await page.setViewport({ width: 1280, height: 800 });
      await page.setUserAgent('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36');

      // Navigate to the events page
      console.log(`Navigating to ${this.url}`);
      await page.goto(this.url, {
        waitUntil: 'networkidle2',
        timeout: 60000
      });

      // Extract events from the main events page
      const extractedEvents = await page.evaluate(() => {
        const events = [];

        // Look for event containers
        const eventElements = Array.from(document.querySelectorAll('-item, , article, .post, .card, .content-block, -listing'));

        eventElements.forEach(element => {
          // Extract event data
          const title = element.querySelector('h2, h3, h4, .title, -title')?.textContent.trim() || '';
          if (!title) return;

          const description = element.querySelector('p, .description, .excerpt, .summary')?.textContent.trim() || '';
          const dateText = element.querySelector('.date, -date, time, .datetime')?.textContent.trim() || '';

          // Get image if available
          let imageUrl = '';
          const imgElement = element.querySelector('img');
          if (imgElement && imgElement.src) {
            imageUrl = imgElement.src;
          }

          // Get link to event page if available
          let link = '';
          const linkElement = element.querySelector('a[href]');
          if (linkElement) {
            try {
              link = new URL(linkElement.href, window.location.href).href;
            } catch (e) {
              // Use relative link if URL construction fails
              link = linkElement.getAttribute('href');
            }
          }

          // Only include events with a title
          if (title) {
            events.push({
              title,
              description,
              dateText,
              imageUrl,
              link
            });
          }
        });

        return events;
      });

      // Process each extracted event
      for (const eventData of extractedEvents) {
        const { title, description, dateText, imageUrl, link } = eventData;

        // Parse date information
        const dateInfo = this.parseDateRange(dateText);

        // Skip events with no dates
        if (!dateInfo.startDate && !dateInfo.endDate) {
          console.log(`Skipping event "${title}" due to missing or invalid date: "${dateText}"`);
          continue;
        }

        // Generate event ID
        const eventId = this.generateEventId(title, dateInfo.startDate);

        // Create event object
        const event = this.createEventObject(
          eventId,
          title,
          description,
          dateInfo.startDate,
          dateInfo.endDate,
          imageUrl,
          link || this.url
        );

        events.push(event);
      }

      // If no events found on the main page, look for an upcoming events section or calendar
      if (events.length === 0) {
        // Check for a "Calendar" or "Upcoming Events" section
        const calendarPages = [
          '/calendar/',
          '/upcoming-events/',
          '/exhibitions/',
          '/whats-on/'
        ];

        for (const calendarPath of calendarPages) {
          try {
            const calendarUrl = new URL(calendarPath, 'https://moa.ubc.ca').href;
            console.log(`Checking for events at: ${calendarUrl}`);

            await page.goto(calendarUrl, { waitUntil: 'networkidle2', timeout: 30000 });

            // Extract events from calendar page
            const calendarEvents = await page.evaluate(() => {
              const events = [];

              // Look for event elements
              const eventElements = Array.from(document.querySelectorAll(', .calendar-event, .exhibition, article, .card'));

              eventElements.forEach(el => {
                const title = el.querySelector('h2, h3, h4, .title, -title')?.textContent.trim() || '';
                if (!title) return;

                const description = el.querySelector('p, .description, .excerpt')?.textContent.trim() || '';
                const dateText = el.querySelector('.date, -date, time, .datetime')?.textContent.trim() || '';

                const imgElement = el.querySelector('img');
                const imageUrl = imgElement ? imgElement.src : '';

                const linkElement = el.querySelector('a[href]');
                const link = linkElement ? new URL(linkElement.href, window.location.href).href : '';

                if (title) {
                  events.push({
                    title,
                    description,
                    dateText,
                    imageUrl,
                    link
                  });
                }
              });

              return events;
            });

            // Process calendar events
            for (const eventData of calendarEvents) {
              const dateInfo = this.parseDateRange(eventData.dateText);

              // Skip events with no dates
              if (!dateInfo.startDate && !dateInfo.endDate) continue;

              // Generate event ID
              const eventId = this.generateEventId(eventData.title, dateInfo.startDate);

              // Create event object
              const event = this.createEventObject(
                eventId,
                eventData.title,
                eventData.description,
                dateInfo.startDate,
                dateInfo.endDate,
                eventData.imageUrl,
                eventData.link || calendarUrl
              );

              events.push(event);
            }

            // If we found events on this page, no need to check others
            if (calendarEvents.length > 0) {
              break;
            }
          } catch (error) {
            console.log(`Error checking ${calendarPath}: ${error.message}`);
            continue;
          }
        }
      }

      // If we still have no events, check the current exhibitions
      if (events.length === 0) {
        try {
          const exhibitionsUrl = 'https://moa.ubc.ca/exhibitions/';
          console.log(`Checking for exhibitions at: ${exhibitionsUrl}`);

          await page.goto(exhibitionsUrl, { waitUntil: 'networkidle2', timeout: 30000 });

          // Extract exhibition items
          const exhibitions = await page.evaluate(() => {
            const items = [];

            // Look for exhibition elements
            const exhibitionElements = Array.from(document.querySelectorAll('.exhibition, article, .card, .content-block'));

            exhibitionElements.forEach(el => {
              const title = el.querySelector('h2, h3, h4, .title')?.textContent.trim() || '';
              if (!title) return;

              const description = el.querySelector('p, .description, .excerpt')?.textContent.trim() || '';
              let dateText = el.querySelector('.date, .exhibition-date, time')?.textContent.trim() || '';

              // Many exhibition pages include dates in the description if not in a specific date element
              if (!dateText && description) {
                const dateMatch = description.match(/(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+,\s+202\d\s*[-â€“â€”]\s*(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+,\s+202\d/i);
                if (dateMatch) {
                  dateText = dateMatch[0];
                }
              }

              const imgElement = el.querySelector('img');
              const imageUrl = imgElement ? imgElement.src : '';

              const linkElement = el.querySelector('a[href]');
              const link = linkElement ? new URL(linkElement.href, window.location.href).href : '';

              if (title) {
                items.push({
                  title,
                  description,
                  dateText,
                  imageUrl,
                  link
                });
              }
            });

            return items;
          });

          // Process exhibitions as events
          for (const exhibition of exhibitions) {
            const dateInfo = this.parseDateRange(exhibition.dateText);

            // For exhibitions without clear dates, use a default range
            let startDate = dateInfo.startDate;
            let endDate = dateInfo.endDate;

            if (!startDate || !endDate) {
              // Default to current year exhibition
              const now = new Date();
              startDate = new Date(now.getFullYear(), 0, 1); // Jan 1 current year
              endDate = new Date(now.getFullYear(), 11, 31, 23, 59, 59); // Dec 31 current year
            }

            // Generate exhibition ID
            const exhibitionId = this.generateEventId(exhibition.title, startDate);

            // Create exhibition event object
            const exhibitionEvent = this.createEventObject(
              exhibitionId,
              exhibition.title,
              exhibition.description,
              startDate,
              endDate,
              exhibition.imageUrl,
              exhibition.link || exhibitionsUrl
            );

            events.push(exhibitionEvent);
          }
        } catch (error) {
          console.log(`Error checking exhibitions: ${error.message}`);
        }
      }

      console.log(`Found ${events.length} events from ${this.name}`);

    } catch (error) {
      console.error(`Error scraping ${this.name}: ${error.message}`);
    } finally {
      if (browser) {
        await browser.close();
      }
    }

    return events;
  }
}

module.exports = new MuseumOfAnthropologyEvents();

// Function export for compatibility with runner/validator
module.exports = async (city) => {
  const scraper = new MuseumOfAnthropologyEvents();
  return await scraper.scrape(city);
};

// Also export the class for backward compatibility
module.exports.MuseumOfAnthropologyEvents = MuseumOfAnthropologyEvents;
