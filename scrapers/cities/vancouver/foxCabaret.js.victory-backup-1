const { getCityFromArgs } = require('../../utils/city-util.js');

  parseTextForDate(text) {
    try {
      if (!text) return null;
      
      const lowerText = text.toLowerCase();
      const now = new Date();
      const result = new Date();
      
      // Extract month names or numbers
      const months = ['january', 'february', 'march', 'april', 'may', 'june', 
                     'july', 'august', 'september', 'october', 'november', 'december'];
      const monthAbbr = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
      
      // Try to find a month in the text
      let foundMonth = false;
      let month = -1;
      
      // Check for month names
      for (let i = 0; i < months.length; i++) {
        if (lowerText.includes(months[i]) || lowerText.includes(monthAbbr[i])) {
          month = i;
          foundMonth = true;
          break;
        }
      }
      
      // Check for numeric month (MM/DD format)
      if (!foundMonth) {
        const dateMatch = lowerText.match(/(\d{1,2})[\/\-\.](\d{1,2})(?:[\/\-\.](\d{2,4}))?/);
        if (dateMatch) {
          month = parseInt(dateMatch[1], 10) - 1; // 0-indexed month
          const day = parseInt(dateMatch[2], 10);
          let year = dateMatch[3] ? parseInt(dateMatch[3], 10) : now.getFullYear();
          
          // Handle 2-digit years
          if (year < 100) {
            year = year < 50 ? 2000 + year : 1900 + year;
          }
          
          result.setFullYear(year, month, day);
          
          // Look for time information after the date
          const timeAfterDate = lowerText.substring(lowerText.indexOf(dateMatch[0]) + dateMatch[0].length);
          const timeMatch = timeAfterDate.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/);
          
          if (timeMatch) {
            let hours = parseInt(timeMatch[1], 10);
            const minutes = timeMatch[2] ? parseInt(timeMatch[2], 10) : 0;
            const ampm = timeMatch[3]?.toLowerCase();
            
            if (ampm === 'pm' && hours < 12) hours += 12;
            if (ampm === 'am' && hours === 12) hours = 0;
            
            result.setHours(hours, minutes, 0, 0);
          }
          
          return result;
        }
      }
      
      // If we found a month
      if (foundMonth) {
        // Look for a day
        const dayMatch = lowerText.match(/\b(\d{1,2})(?:st|nd|rd|th)?\b/);
        const day = dayMatch ? parseInt(dayMatch[1], 10) : 1;
        
        // Look for a year
        const yearMatch = lowerText.match(/\b(20\d{2})\b/);
        const year = yearMatch ? parseInt(yearMatch[1], 10) : now.getFullYear();
        
        // Look for time
        const timeMatch = lowerText.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/);
        
        result.setFullYear(year, month, day);
        
        if (timeMatch) {
          let hours = parseInt(timeMatch[1], 10);
          const minutes = timeMatch[2] ? parseInt(timeMatch[2], 10) : 0;
          const ampm = timeMatch[3]?.toLowerCase();
          
          if (ampm === 'pm' && hours < 12) hours += 12;
          if (ampm === 'am' && hours === 12) hours = 0;
          
          result.setHours(hours, minutes, 0, 0);
        }
        
        return result;
      }
      
      // Handle relative dates
      const relativeTerms = {
        'today': 0,
        'tonight': 0,
        'tomorrow': 1,
        'this week': 3,
        'next week': 7,
        'this weekend': 5,
        'next weekend': 12
      };
      
      for (const [term, daysToAdd] of Object.entries(relativeTerms)) {
        if (lowerText.includes(term)) {
          result.setDate(now.getDate() + daysToAdd);
          
          // Set evening time for 'tonight'
          if (term === 'tonight') {
            result.setHours(20, 0, 0, 0);
          }
          
          return result;
        }
      }
      
      return null;
    } catch (error) {
      console.error('Error parsing text for date:', error);
      return null;
    }
  }

  /**
   * Determine event categories based on event title
   * @param {string} title - Event title
   * @returns {Array<string>} - Array of category strings
   */
  determineCategories(title) {
    const text = title.toLowerCase();
    
    if (text.includes('concert') || text.includes('music') || 
        text.includes('band') || text.includes('dj') || 
        text.includes('live music') || text.includes('singer') ||
        text.includes('show')) {
      return ['Music', 'Entertainment'];
    }
    
    if (text.includes('comedy') || text.includes('comedian') || 
        text.includes('stand-up') || text.includes('laugh')) {
      return ['Comedy', 'Entertainment'];
    }
    
    if (text.includes('dance') || text.includes('dancing') || 
        text.includes('party')) {
      return ['Dance', 'Nightlife'];
    }
    
    if (text.includes('film') || text.includes('movie') || 
        text.includes('cinema') || text.includes('screening')) {
      return ['Film', 'Arts & Culture'];
    }
    
    if (text.includes('art') || text.includes('exhibition') || 
        text.includes('gallery') || text.includes('culture')) {
      return ['Arts & Culture'];
    }
    
    // Fox Cabaret often hosts cabaret and performance art
    if (text.includes('cabaret') || text.includes('burlesque') || 
        text.includes('performance art') || text.includes('drag')) {
      return ['Performance Art', 'Nightlife'];
    }
    
    // Default category
    return ['Entertainment', 'Nightlife'];
  }

  /**
   * Determine season based on date
   * @param {Date} date - Date object
   * @returns {string} - Season name
   */
  determineSeason(date) {
    if (!date || isNaN(date.getTime())) return 'Unknown';
    
    const month = date.getMonth();
    
    if (month >= 2 && month <= 4) return 'Spring'; // March to May
    if (month >= 5 && month <= 7) return 'Summer'; // June to August
    if (month >= 8 && month <= 10) return 'Fall';  // September to November
    return 'Winter';                               // December to February
  }
}

// Export the scraper class
module.exports = new FoxCabaretScraper();

// Function export for compatibility with runner/validator
module.exports = async (city) => {
  const scraper = new FoxCabaretScraper();
  return await scraper.scrape(city);
};

// Also export the class for backward compatibility
module.exports.FoxCabaretScraper = FoxCabaretScraper;
