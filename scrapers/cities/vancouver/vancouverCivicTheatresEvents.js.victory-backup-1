const { getCityFromArgs } = require('../../utils/city-util.js');

  parseDates(dateText) {
    try {
      if (!dateText) {
        // Default to current date if no date text
        const today = new Date();
        return { startDate: today, endDate: today };
      }
      
      // Clean up the date text
      dateText = dateText.trim();
      
      // Check if we have a date range with format like "MAY 8-21" or "JUL 4 - AUG 9"
      const rangePattern = /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s*(\d{1,2})\s*[-â€“]\s*(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)?\s*(\d{1,2})\b/i;
      const rangeMatch = dateText.match(rangePattern);
      
      if (rangeMatch) {
        const startMonth = rangeMatch[1].toLowerCase();
        const startDay = parseInt(rangeMatch[2]);
        // If end month is specified use it, otherwise use start month
        const endMonth = (rangeMatch[3] || rangeMatch[1]).toLowerCase();
        const endDay = parseInt(rangeMatch[4]);
        
        // Convert month names to month numbers
        const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
        const startMonthNum = monthNames.indexOf(startMonth.slice(0, 3));
        const endMonthNum = monthNames.indexOf(endMonth.slice(0, 3));
        
        const currentYear = new Date().getFullYear();
        
        const startDate = new Date(currentYear, startMonthNum, startDay);
        const endDate = new Date(currentYear, endMonthNum, endDay);
        
        return { startDate, endDate };
      }
      
      // Check for a single date with month and day
      const singlePattern = /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s*(\d{1,2})(st|nd|rd|th)?\b/i;
      const singleMatch = dateText.match(singlePattern);
      
      if (singleMatch) {
        const month = singleMatch[1].toLowerCase();
        const day = parseInt(singleMatch[2]);
        
        // Convert month name to month number
        const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
        const monthNum = monthNames.indexOf(month.slice(0, 3));
        
        const currentYear = new Date().getFullYear();
        const date = new Date(currentYear, monthNum, day);
        
        return { startDate: date, endDate: date };
      }
      
      // Look for a date in the format "FRIDAY JULY 11TH"
      const fullDatePattern = /\b(monday|tuesday|wednesday|thursday|friday|saturday|sunday)?\s*(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s*(\d{1,2})(st|nd|rd|th)?\b/i;
      const fullDateMatch = dateText.match(fullDatePattern);
      
      if (fullDateMatch) {
        const month = fullDateMatch[2].toLowerCase();
        const day = parseInt(fullDateMatch[3]);
        
        // Convert month name to month number
        const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
        const monthNum = monthNames.indexOf(month.slice(0, 3));
        
        const currentYear = new Date().getFullYear();
        const date = new Date(currentYear, monthNum, day);
        
        return { startDate: date, endDate: date };
      }
      
      // Look for a date in the format "2025-07-15"
      const isoDatePattern = /\b(\d{4})-(\d{1,2})-(\d{1,2})\b/;
      const isoDateMatch = dateText.match(isoDatePattern);
      
      if (isoDateMatch) {
        const year = parseInt(isoDateMatch[1]);
        const month = parseInt(isoDateMatch[2]) - 1; // JavaScript months are 0-indexed
        const day = parseInt(isoDateMatch[3]);
        
        const date = new Date(year, month, day);
        
        return { startDate: date, endDate: date };
      }
      
      // Last resort: Try to parse the date directly
      const parsedDate = new Date(dateText);
      if (!isNaN(parsedDate.getTime())) {
        return { startDate: parsedDate, endDate: parsedDate };
      }
      
      // If all else fails, return today's date
      const today = new Date();
      return { startDate: today, endDate: today };
    } catch (error) {
      console.error('Error parsing dates:', error);
      const today = new Date();
      return { startDate: today, endDate: today };
    }
  }
  
  /**
   * Scroll the page to trigger lazy loading with human-like behavior
   * @param {Page} page - Puppeteer page object
   */
  async scrollPage(page) {
    // Get page height for intelligent scrolling
    const pageHeight = await page.evaluate(() => document.body.scrollHeight);
    
    console.log(`Scrolling page with height ${pageHeight}px to load dynamic content...`);
    
    // Human-like scrolling pattern with random pauses
    await page.evaluate(async () => {
      const randomScrollDelay = (min, max) => {
        const delay = Math.floor(Math.random() * (max - min + 1) + min);
        return new Promise(resolve => setTimeout(resolve, delay));
      };
      
      // Initial pause like a human would do
      await randomScrollDelay(500, 1500);
      
      // Random number of scrolls (5-8) with varying distances
      const scrollCount = Math.floor(Math.random() * 4) + 5;
      
      for (let i = 0; i < scrollCount; i++) {
        // Random scroll distance between 300-800px
        const scrollDistance = Math.floor(Math.random() * 500) + 300;
        window.scrollBy(0, scrollDistance);
        
        // Random pause between scrolls (400-2000ms)
        await randomScrollDelay(400, 2000);
        
        // Small chance (20%) to scroll back up slightly to simulate reading behavior
        if (Math.random() < 0.2) {
          window.scrollBy(0, -Math.floor(Math.random() * 200));
          await randomScrollDelay(300, 800);
        }
      }
      
      // Final scroll to bottom to ensure all content is loaded
      window.scrollTo(0, document.body.scrollHeight);
      await randomScrollDelay(1000, 2000);
      
      // Scroll back up a bit as a user would do after reaching the bottom
      window.scrollBy(0, -Math.floor(Math.random() * 500));
    });
    
    // Wait for any lazy-loaded content to appear using setTimeout instead of waitForTimeout
    await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 1000));
  }

  /**
   * Calculate relevance score for event links
   * @param {Object} link - Link object with href and text properties
   * @returns {number} - Relevance score
   */
  getLinkRelevanceScore(link) {
    let score = 0;
    const text = (link.text || '').toLowerCase();
    const href = (link.href || '').toLowerCase();
    
    // Higher scores for more relevant terms
    if (text.includes('event') || href.includes('event')) score += 5;
    if (text.includes('concert') || href.includes('concert')) score += 5;
    if (text.includes('performance') || href.includes('performance')) score += 4;
    if (text.includes('orpheum') || href.includes('orpheum')) score += 10;
    if (text.includes('schedule') || href.includes('schedule')) score += 3;
    if (text.includes('calendar') || href.includes('calendar')) score += 3;
    if (text.includes('season') || href.includes('season')) score += 2;
    
    return score;
  }
}

module.exports = new VancouverCivicTheatresEvents();

// Function export for compatibility with runner/validator
module.exports = async (city) => {
  const scraper = new VancouverCivicTheatresEvents();
  return await scraper.scrape(city);
};

// Also export the class for backward compatibility
module.exports.VancouverCivicTheatresEvents = VancouverCivicTheatresEvents;
