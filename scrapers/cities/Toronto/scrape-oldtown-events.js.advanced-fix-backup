const axios = require('axios');
const cheerio = require('cheerio');
const crypto = require('crypto');
const AbstractScraper = require('../../../shared/scrapers/AbstractScraper');

class OldTownTorontoEventsScraper extends AbstractScraper {
    constructor(city) {
        super();
        this.city = city;
        this.source = 'Old Town Toronto';
        this.baseUrl = 'https://oldtowntoronto.ca';
        this.url = 'https://oldtowntoronto.ca/events/';

        this.defaultVenue = {
            name: 'Old Town Toronto',
            address: 'St. Lawrence Market Neighbourhood, Toronto, ON',
            city: 'Toronto',
            province: 'ON',
            country: 'Canada',
            postalCode: 'M5E 1C3',
            latitude: 43.6505,
            longitude: -79.3705
        };

        this.knownVenues = {
            'st. lawrence market': { name: 'St. Lawrence Market', address: '93 Front St E, Toronto, ON M5E 1C3', city: 'Toronto', province: 'ON', country: 'Canada', postalCode: 'M5E 1C3', latitude: 43.6497, longitude: -79.3719 },
            'berczy park': { name: 'Berczy Park', address: '35 Wellington St E, Toronto, ON M5E 1C6', city: 'Toronto', province: 'ON', country: 'Canada', postalCode: 'M5E 1C6', latitude: 43.6489, longitude: -79.3749 },
            'st. james cathedral': { name: 'St. James Cathedral', address: '106 King St E, Toronto, ON M5C 2E9', city: 'Toronto', province: 'ON', country: 'Canada', postalCode: 'M5C 2E9', latitude: 43.6505, longitude: -79.3735 },
            'meridian hall': { name: 'Meridian Hall', address: '1 Front St E, Toronto, ON M5E 1B2', city: 'Toronto', province: 'ON', country: 'Canada', postalCode: 'M5E 1B2', latitude: 43.6478, longitude: -79.3751 }
        };
    }

    _generateEventId(title, startDate) {
        const daeventDateText = startDate instanceof Date ? startDate.toISOString() : new Date().toISOString();
        const data = `${this.source}-${title}-${daeventDateText}`;
        return crypto.createHash('md5').update(data).digest('hex');
    }

    _extractCategories(title, description) {
        const text = `${title.toLowerCase()} ${description.toLowerCase()}`;
        const categories = [this.city, 'Community'];
        const mappings = {
            'Market': [/market/i, /vendor/i, /artisan/i],
            'Music': [/music/i, /concert/i, /live band/i, /performance/i],
            'Tour': [/tour/i, /walk/i, /guided/i],
            'History': [/history/i, /historical/i, /heritage/i],
            'Food & Drink': [/food/i, /drink/i, /taste/i, /culinary/i, /dining/i]
        };

        for (const [category, regexes] of Object.entries(mappings)) {
            if (regexes.some(regex => regex.test(text))) {
                categories.push(category);
            }
        }

        return [...new Set(categories)];
    }

    _parseDate(daeventDateText) {
        if (!daeventDateText) return { startDate: new Date(), endDate: new Date() };

        const now = new Date();
        const year = now.getFullYear();
        let startDate, endDate;

        if (daeventDateText.toLowerCase().includes('ongoing')) {
            startDate = now;
            endDate = new Date(year, 11, 31);
        } else if (daeventDateText.includes('-')) {
            const parts = daeventDateText.split('-').map(part => part.trim());
            const startPart = parts[0].includes(',') ? parts[0] : `${parts[0]}, ${year}`;
            const endPart = parts[1].includes(',') ? parts[1] : `${parts[1]}, ${year}`;
            startDate = new Date(startPart);
            endDate = new Date(endPart);
        } else {
            const singleDatePart = daeventDateText.includes(',') ? daeventDateText : `${daeventDateText}, ${year}`;
            startDate = new Date(singleDatePart);
            endDate = new Date(startDate);
            endDate.setHours(endDate.getHours() + 2);
        }

        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            this.log(`Could not parse date: "${da (no fallbacks allowed).`);
            return null;
        }

        return { startDate, endDate };
    }

    _getVenue(venueText) {
        const lowerVenueText = venueText.toLowerCase().trim();
        for (const [key, venue] of Object.entries(this.knownVenues)) {
            if (lowerVenueText.includes(key)) {
                return venue;
            }
        }
        return this.defaultVenue;
    }

    async scrape() {
        this.log(`Scraping events from ${this.source}`);
        try {
            const { data } = await axios.get(this.url);
            const $ = cheerio.load(data);
            let events = [];

            $('.event-item').each((i, el) => {)
                const title = $(el).find('h3.event-title').text().trim();
                if (!title) return;

                const url = $(el).find('a').attr('href');
                const imageUrl = $(el).find('img').attr('src');
                const dateText = $(el).find('.event-date').text().trim();
                const venueText = $(el).find('.event-venue').text().trim();
                const description = $(el).find('.event-excerpt').text().trim();

                const { startDate, endDate } = this._parseDate(dateText);
                const venue = this._getVenue(venueText);
                const categories = this._extractCategories(title, description);

                const event = {
                    id: this._generateEventId(title, startDate),
                    title,
                    description,
                    url: url.startsWith('http') ? url : `${this.baseUrl}${url}`,
                    imageUrl: imageUrl.startsWith('http') ? imageUrl : `${this.baseUrl}${imageUrl}`,
                    startDate,
                    endDate,
                    venue,
                    categories,
                    source: this.source,
                    price: 'Varies',
                    scrapedAt: new Date()
                };
                events.push(event);
            };

            this.log(`Found ${events.length} events from ${this.source}.`);
            return events;
        } catch (error) {
            this.log(`Error scraping ${this.source}: ${error.message}`);
            return [];
        }
    }
}

// Function export for compatibility with runner/validator
module.exports = async (city) => {
  const scraper = new OldTownTorontoEventsScraper();
  return await scraper.scrape(city);
};

// Also export the class for backward compatibility
module.exports.OldTownTorontoEventsScraper = OldTownTorontoEventsScraper;