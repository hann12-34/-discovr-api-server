const puppeteer = require('puppeteer');
const crypto = require('crypto');
const AbstractScraper = require('../../../shared/scrapers/AbstractScraper');

class AjaxCommunityEventsScraper extends AbstractScraper {
    constructor(city) {
        super();
        this.city = city;
        this.source = 'Ajax Community Events';
        this.url = 'https://www.ajax.ca/en/play-and-discover/community-events.aspx';
        this.venue = {
            name: 'Various Locations in Ajax',
            address: 'Ajax, ON',
            city: city,
            province: 'ON',
            country: 'Canada',
            postalCode: '',
            latitude: 43.8504,
            longitude: -79.0204
        };
    }

    _generateEventId(title, startDate) {
        const dateStr = startDate instanceof Date ? startDate.toISOString() : new Date().toISOString();
        const data = `${this.source}-${title}-${dateStr}`;
        return crypto.createHash('md5').update(data).digest('hex');
    }

    async scrape() {
        this.log(`Scraping events from ${this.source}`);
        const browser = await puppeteer.launch({ headless: true, args: ['--no-sandbox'] });
        try {
            const page = await browser.newPage();
            await page.goto(this.url, { waitUntil: 'networkidle2' });

            const events = await page.evaluate((venue, source, city) => {
                const eventList = [];
                const eventElements = document.querySelectorAll('.calendar tr[class*="event"]');

                eventElements.forEach(el => {
                    const title = el.querySelector('.subject a')?.innerText.trim();
                    if (!title) return;

                    const url = el.querySelector('.subject a')?.href;
                    const dateText = el.querySelector('.startDate')?.innerText.trim();
                    const timeText = el.querySelector('.startTime')?.innerText.trim();
                    const description = el.querySelector('.description')?.innerText.trim() || '';

                    const date = new Date(`${dateText} ${timeText}`);
                    if (isNaN(date.getTime())) {
                        return; // Skip event if date is invalid
                    }
                    const startDate = date;
                    const endDate = new Date(startDate.getTime() + 2 * 60 * 60 * 1000);

                    const event = {
                        title,
                        description,
                        url,
                        startDate,
                        endDate,
                        venue: {
                name: city, ...venue, city
            },
                        categories: [city, 'Community', 'Festival'],
                        source,
                        price: 'Free',
                        scrapedAt: new Date().toISOString()
                    };
                    eventList.push(event);
                });

                return eventList;
            }, this.venue, this.source, this.city);

            const processedEvents = events.map(event => ({
                ...event,
                id: this._generateEventId(event.title, new Date(event.startDate)),
                startDate: new Date(event.startDate),
                endDate: new Date(event.endDate),
                scrapedAt: new Date(event.scrapedAt)
            }));

            this.log(`Found ${processedEvents.length} events from ${this.source}.`);
            return processedEvents;
        } catch (error) {
            this.log(`Error scraping ${this.source}: ${error.message}`);
            return [];
        } finally {
            await browser.close();
        }
    }
}

// Function export for compatibility with runner/validator
module.exports = async (city) => {
  const scraper = new AjaxCommunityEventsScraper();
  return await scraper.scrape(city);
};

// Also export the class for backward compatibility
module.exports.AjaxCommunityEventsScraper = AjaxCommunityEventsScraper;