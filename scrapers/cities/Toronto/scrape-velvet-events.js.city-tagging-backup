const { getCityFromArgs } = require('../../utils/city-util.js');
/**
 * The Velvet Events Scraper
 * Based on events from http://thevelvet.ca/events/
 */

require('dotenv').config();
const axios = require('axios');
const cheerio = require('cheerio');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');

// Constants
const VELVET_URL = 'http://thevelvet.ca/events/';
const VELVET_VENUE = {
  name: 'The Velvet',
  address: '508 Queen St W, Toronto, ON M5V 2B3',
  city: getCityFromArgs(),
  region: 'Ontario',
  country: 'Canada',
  postalCode: 'M5V 2B3',
  url: 'http://thevelvet.ca',
};

// MongoDB connection URI
const uri = process.env.MONGODB_URI;
if (!uri) {
  console.error('âŒ MONGODB_URI environment variable not set');
  process.exit(1);
}

// Generate unique event ID
function generateEventId(title, startDate) {
  const dataToHash = `${VELVET_VENUE.name}-${title}-${startDate.toISOString()}`;
  return crypto.createHash('md5').update(dataToHash).digest('hex');
}

// Parse date and time information
function parseDateAndTime(dateText, timeText = '') {
  if (!dateText) return null;
  
  try {
    // Clean up texts
    dateText = dateText.trim();
    timeText = timeText ? timeText.trim() : '';
    
    // Remove day of week if present
    dateText = dateText.replace(/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\s*/i, '');
    
    // Remove ordinal indicators (1st, 2nd, 3rd, 4th, etc.) for better date parsing
    dateText = dateText.replace(/(\d+)(st|nd|rd|th)/gi, '$1');
    
    let startDate, endDate;
    
    // Handle various date formats
    const currentYear = new Date().getFullYear();
    
    // Try parsing with current year if no year specified
    if (!dateText.includes(currentYear.toString()) && !dateText.includes((currentYear + 1).toString())) {
      dateText = `${dateText}, ${currentYear}`;
    }
    
    // Parse the date
    startDate = new Date(dateText);
    
    if (isNaN(startDate.getTime())) {
      console.log(`âš ï¸ Could not parse date: "${dateText}"`);
      return null;
    }
    
    // Handle time if provided
    if (timeText) {
      const timeMatch = timeText.match(/(\d{1,2}):?(\d{2})?\s*(AM|PM|am|pm)?/i);
      if (timeMatch) {
        let hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2] || '0');
        const ampm = timeMatch[3];
        
        if (ampm && ampm.toLowerCase() === 'pm' && hours !== 12) {
          hours += 12;
        } else if (ampm && ampm.toLowerCase() === 'am' && hours === 12) {
          hours = 0;
        }
        
        startDate.setHours(hours, minutes, 0, 0);
      }
    }
    
    // Set end date (assume 4 hours duration for nightclub events)
    endDate = new Date(startDate);
    endDate.setHours(endDate.getHours() + 4);
    
    return { startDate, endDate };
    
  } catch (error) {
    console.log(`âš ï¸ Error parsing date "${dateText}": ${error.message}`);
    return null;
  }
}

// Extract categories from event title and description
function extractCategories(title, description, eventType = '') {
  const categories = [];
  const text = `${title} ${description} ${eventType}`.toLowerCase();
  
  // Nightlife and club categories
  if (text.match(/\b(dj|dance|club|party|nightlife|electronic|house|techno|edm)\b/)) {
    categories.push('Nightlife');
  }
  if (text.match(/\b(live music|concert|band|performance|music)\b/)) {
    categories.push('Music');
  }
  if (text.match(/\b(hip hop|r&b|rap|urban)\b/)) {
    categories.push('Hip Hop');
  }
  if (text.match(/\b(latin|reggaeton|salsa|bachata)\b/)) {
    categories.push('Latin');
  }
  if (text.match(/\b(special|vip|guest|celebrity|exclusive)\b/)) {
    categories.push('Special Events');
  }
  if (text.match(/\b(weekend|friday|saturday)\b/)) {
    categories.push('Weekend Events');
  }
  if (text.match(/\b(drag|lgbtq|pride|queer)\b/)) {
    categories.push('LGBTQ+');
  }
  if (text.match(/\b(karaoke|open mic|talent)\b/)) {
    categories.push('Interactive');
  }
  
  return categories.length > 0 ? categories : ['Nightlife'];
}

// Extract price information
function extractPrice(text) {
  if (!text) return 'Contact venue';
  
  const priceMatch = text.match(/\$(\d+(?:\.\d{2})?)/);
  if (priceMatch) {
    return `$${priceMatch[1]}`;
  }
  
  if (text.toLowerCase().includes('free')) {
    return 'Free';
  }
  
  return 'Contact venue';
}

// Normalize URL to absolute
function normalizeUrl(url, baseUrl = 'http://thevelvet.ca') {
  if (!url) return '';
  if (url.startsWith('http')) return url;
  return url.startsWith('/') ? `${baseUrl}${url}` : `${baseUrl}/${url}`;
}

// Main scraper function for sample runner
async function scrapeVelvetEvents(city = 'Toronto') {
  const eventsToReturn = [];
  
  try {
    console.log('ğŸ” Fetching events from The Velvet website...');
    
    // Fetch HTML content
    const response = await axios.get(VELVET_URL, {
      timeout: 15000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate, br',
        'DNT': '1',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Cache-Control': 'max-age=0'
      }
    });
    const html = response.data;
    const $ = cheerio.load(html);
    
    const events = [];
    
    // Look for event information in various selectors - comprehensive approach
    console.log('ğŸ” Analyzing website structure...');
    
    // First, try specific event selectors
    let eventElements = $('.event, .event-item, .party, .show, .listing, article, .grid-item, .event-card, .wp-block-post, .post, .entry, .event-entry, [class*="event"], [class*="show"], [class*="party"]');
    
    // If no events found, try broader approach
    if (eventElements.length === 0) {
      console.log('âš ï¸ No events found with standard selectors, trying broader approach...');
      eventElements = $('div, section, article').filter(function() {
        const text = $(this).text().toLowerCase();
        return text.includes('event') || text.includes('show') || text.includes('party') || 
               text.includes('music') || text.includes('dj') || text.includes('live') ||
               text.includes('2024') || text.includes('2025');
      });
    }
    
    console.log(`ğŸ“‹ Found ${eventElements.length} potential event elements`);
    
    eventElements.each((i, el) => {
      try {
        const element = $(el);
        
        const title = element.find('h1, h2, h3, h4, .title, .event-title, .party-title').first().text().trim() ||
                     element.find('.artist, .dj, .performer').first().text().trim();
        const dateText = element.find('.date, .when, time, .event-date').first().text().trim();
        const timeText = element.find('.time, .event-time').first().text().trim();
        const description = element.find('p, .description, .details, .event-description').first().text().trim() || 
                           'Join us at The Velvet for an intimate nightlife experience with great music and atmosphere.';
        
        let imageUrl = '';
        const imgEl = element.find('img');
        if (imgEl.length) {
          imageUrl = imgEl.attr('src') || imgEl.attr('data-src') || '';
          imageUrl = normalizeUrl(imageUrl);
        }
        
        let eventUrl = '';
        const linkEl = element.find('a[href]');
        if (linkEl.length) {
          eventUrl = linkEl.attr('href');
          eventUrl = normalizeUrl(eventUrl);
        }
        
        if (title && title.length > 3) {
          events.push({
            title,
            dateText,
            timeText,
            description,
            imageUrl,
            eventUrl: eventUrl || VELVET_URL
          });
        }
      } catch (error) {
        console.log(`âš ï¸ Error processing event element: ${error.message}`);
      }
    });
    
    // No s allowed per user rule
    
    console.log(`ğŸ“… Found ${events.length} potential events`);
    
    // Process each event
    for (const event of events) {
      const dateTimeResult = parseDateAndTime(event.dateText, event.timeText);
      
      if (!dateTimeResult) {
        console.log(`âš ï¸ Skipping event "${event.title}" - could not parse date`);
        continue;
      }
      
      const { startDate, endDate } = dateTimeResult;
      const eventId = generateEventId(event.title, startDate);
      
      // Skip duplicate checking for now - let the sample runner handle it with upsert
      
      const categories = extractCategories(event.title, event.description);
      const price = extractPrice(event.description);
      
      const eventDoc = {
        id: eventId,
        title: event.title,
        name: event.title,
        description: event.description,
        date: startDate,
        startDate,
        endDate,
        venue: {
          name: city, // Use city name for proper filtering
          address: VELVET_VENUE.address,
          city: city,
          region: VELVET_VENUE.region,
          country: VELVET_VENUE.country,
          postalCode: VELVET_VENUE.postalCode
        },
        city: city,
        categories,
        price,
        source: 'The Velvet',
        url: event.eventUrl,
        sourceUrl: event.eventUrl,
        imageUrl: event.imageUrl,
        image: event.imageUrl,
        scrapedAt: new Date(),
        isActive: true
      };
      
      eventsToReturn.push(eventDoc);
      console.log(`âœ… Prepared event: ${event.title} on ${startDate.toDateString()}`);
    }
    
    console.log(`ğŸ‰ Successfully prepared ${eventsToReturn.length} events from The Velvet`);
    
  } catch (error) {
    console.error('âŒ Error scraping The Velvet events:', error);
  }
  
  return eventsToReturn;
}

// Standalone scraper function (for direct execution)
async function scrapeVelvetEventsStandalone() {
  const client = new MongoClient(uri);
  
  try {
    await client.connect();
    console.log('âœ… Connected to MongoDB');
    
    const database = client.db();
    const eventsCollection = databases');
    
    const addedEvents = await scrapeVelvetEvents(eventsCollection);
    return addedEvents;
    
  } catch (error) {
    console.error('âŒ Error in standalone scraper:', error);
    return 0;
  } finally {
    await client.close();
    console.log('âœ… MongoDB connection closed');
  }
}

// Export for master scraper
module.exports = { scrapeVelvetEvents };

// Run the scraper if executed directly
if (require.main === module) {
  scrapeVelvetEventsStandalone()
    .then(addedEvents => {
      console.log(`âœ… The Velvet scraper completed. Added ${addedEvents} new events.`);
    })
    .catch(error => {
      console.error('âŒ Error running The Velvet scraper:', error);
      process.exit(1);
    });
}
