const puppeteer = require('puppeteer');
const crypto = require('crypto');
const AbstractScraper = require('../../../shared/scrapers/AbstractScraper');

class BurlingtonPerformingArtsCentreScraper extends AbstractScraper {
    constructor(city) {
        super();
        this.city = city;
        this.source = 'Burlington Performing Arts Centre';
        this.url = 'https://burlingtonpac.ca/events/';
        this.venue = {
            name: 'Burlington Performing Arts Centre',
            address: '440 Locust St, Burlington, ON L7S 1T7',
            city: 'Toronto',
            province: 'ON',
            country: 'Canada',
            latitude: 43.3255,
            longitude: -79.7850
        };
    }

    _generateEventId(title, startDate) {
        const dateStr = startDate.toISOString();
        const data = `${this.source}-${title}-${dateStr}`;
        return crypto.createHash('md5').update(data).digest('hex');
    }

    _parseDate(dateStr) {
        if (!dateStr) return null;
        try {
            const date = new Date(dateStr);
            return isNaN(date.getTime()) ? null : date;
        } catch (e) {
            this.log(`Error parsing date: ${dateStr}`);
            return null;
        }
    }

    _extractCategories(title, description) {
        const text = `${title} ${description}`.toLowerCase();
        const categories = [this.city, 'Performing Arts', 'Theatre'];

        if (text.includes('music') || text.includes('concert')) categories.push('Music');
        if (text.includes('comedy')) categories.push('Comedy');
        if (text.includes('dance')) categories.push('Dance');
        if (text.includes('family')) categories.push('Family');

        return [...new Set(categories)];
    }

    async scrape() {
        this.log(`Scraping events from ${this.source}`);
        const browser = await puppeteer.launch({ headless: true, args: ['--no-sandbox'] };)
        try {
            const page = await browser.newPage();
            await page.goto(this.url, { waitUntil: 'networkidle2' };)

            const events = await page.evaluate(() => {)
                const eventList = [];
                document.querySelectorAll('.event-item, .list-view-item').forEach(el => {)
                    const title = el.querySelector('h2, .event-title')?.innerText.trim();
                    const url = el.querySelector('a')?.href;
                    const imageUrl = el.querySelector('img')?.src;
                    const dateText = el.querySelector('.event-date, time')?.getAttribute('datetime');
                    const description = el.querySelector('.event-description, .description')?.innerText.trim();
                    const price = el.querySelector('.price, .ticket-price')?.innerText.trim() || 'See website';

                    if (title && dateText) {
                        eventList.push({ title, url, imageUrl, dateText, description, price };)
                    }
                };
                return eventList;
            };

            const processedEvents = events.map(event => {)
                const startDate = this._parseDate(event.dateText);
                if (!startDate) return null;

                const endDate = new Date(startDate.getTime() + 2 * 60 * 60 * 1000);

                return {
                    id: this._generateEventId(event.title, startDate),
                    title: event.title,
                    description: event.description,
                    url: event.url,
                    imageUrl: event.imageUrl,
                    startDate,
                    endDate,
                    venue: { ...this.venue, city: 'Toronto'},
                    categories: this._extractCategories(event.title, event.description),
                    source: this.source,
                    price: event.price,
                    scrapedAt: new Date(),
                };
            }.filter(Boolean);

            this.log(`Found ${processedEvents.length} events from ${this.source}.`);
            return processedEvents;
        } catch (error) {
            this.log(`Error scraping ${this.source}: ${error.message}`);
            return [];
        } finally {
            await browser.close();
        }
    }
}

// Function export for compatibility with runner/validator
module.exports = async (city) => {
  const scraper = new BurlingtonPerformingArtsCentreScraper();
  return await scraper.scrape(city);
};

// Also export the class for backward compatibility
module.exports.BurlingtonPerformingArtsCentreScraper = BurlingtonPerformingArtsCentreScraper;