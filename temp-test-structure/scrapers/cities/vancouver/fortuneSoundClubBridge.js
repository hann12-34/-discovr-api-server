/**
 * Fortune Sound Club Scraper Bridge
 * Reads events from the Python Fortune Sound Club scraper output
 * and integrates them with the Discovr API
 */

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const { v5: uuidv5 } = require('uuid');

// Unique namespace for generating deterministic IDs
const NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';

class FortuneSoundClubBridge {
  constructor() {
    this.name = 'Fortune Sound Club';
    this.sourceIdentifier = 'fortune-sound-club';
    this.enabled = true;
    this.pythonScraperPath = path.join(__dirname, '..', '..', '..', 'Scrapers', 'FortuneSound');
    this.pythonScraperScript = path.join(this.pythonScraperPath, 'fortune_scraper.py');
    this.outputJsonPath = path.join(this.pythonScraperPath, 'fortune_events.json');
    this.venue = {
      name: 'Fortune Sound Club',
      address: '147 E Pender St',
      city: 'Vancouver',
      state: 'BC',
      country: 'Canada',
      coordinates: { lat: 49.2801, lng: -123.1022 }
    };
  }

  /**
   * Main scraper method - runs Python scraper and reads output
   * @returns {Promise<Array>} - Scraped event data
   */
  async scrape() {
    try {
      console.log(`ðŸŽµ Scraping ${this.name} events via Python bridge...`);
      
      // First, check if there's a recent JSON file (< 24 hours old)
      if (await this.hasRecentJsonFile()) {
        console.log(`Using existing JSON file (${this.outputJsonPath})`);
      } else {
        // Run the Python scraper
        await this.runPythonScraper();
      }
      
      // Read and parse the events from JSON
      const events = await this.readEventsFromJson();
      
      console.log(`${this.name} Python bridge: Found ${events.length} events`);
      return events;
    } catch (error) {
      console.error(`Error scraping ${this.name}:`, error.message);
      return [];
    }
  }
  
  /**
   * Check if there's a recent JSON file (less than 24 hours old)
   * @returns {Promise<boolean>}
   */
  async hasRecentJsonFile() {
    try {
      const stats = fs.statSync(this.outputJsonPath);
      const fileAge = Date.now() - stats.mtimeMs;
      // Return true if file exists and is less than 24 hours old
      return fileAge < 24 * 60 * 60 * 1000;
    } catch (err) {
      // File doesn't exist or can't be accessed
      return false;
    }
  }

  /**
   * Run the Python scraper to generate fresh event data
   * @returns {Promise<void>}
   */
  async runPythonScraper() {
    return new Promise((resolve, reject) => {
      console.log(`Running Python scraper: ${this.pythonScraperScript}`);
      
      // Execute the Python script
      exec(`cd ${this.pythonScraperPath} && python3 fortune_scraper.py`, 
        (error, stdout, stderr) => {
          if (error) {
            console.error(`Error running Python scraper: ${error.message}`);
            reject(error);
            return;
          }
          
          if (stderr) {
            console.warn(`Python scraper warning: ${stderr}`);
          }
          
          console.log(`Python scraper output: ${stdout}`);
          resolve();
        }
      );
    });
  }

  /**
   * Read events from the JSON file generated by the Python scraper
   * @returns {Promise<Array>} - Parsed events
   */
  async readEventsFromJson() {
    try {
      const data = fs.readFileSync(this.outputJsonPath, 'utf8');
      const parsedData = JSON.parse(data);
      
      // Transform events to match expected format
      return parsedData.map(event => this.formatEvent(event));
    } catch (error) {
      console.error(`Error reading events from JSON: ${error.message}`);
      return [];
    }
  }

  /**
   * Format event to match Discovr API schema
   * @param {Object} event - Raw event data from Python scraper
   * @returns {Object} - Formatted event
   */
  formatEvent(event) {
    // Generate deterministic ID (if not already present)
    const id = event.id || uuidv5(`${event.name || event.title}-${this.venue.name}-${event.startDate || new Date().toISOString()}`, NAMESPACE);
    
    // Parse dates if they're strings
    let startDate = event.startDate;
    if (typeof startDate === 'string') {
      startDate = new Date(startDate);
    } else if (!startDate) {
      startDate = new Date();
    }
    
    // Format the event to match expected schema
    return {
      id: id,
      title: event.title || event.name,
      name: event.name || event.title,
      description: event.description || `Event at ${this.venue.name}`,
      image: event.image,
      date: startDate.toISOString(),
      startDate: startDate,
      endDate: event.endDate ? new Date(event.endDate) : null,
      season: this.determineSeason(startDate),
      category: event.category || event.categories?.[0] || 'Nightlife',
      categories: event.categories || ['Music', 'Nightlife'],
      location: this.venue.name,
      venue: this.venue,
      sourceURL: event.sourceURL || event.officialWebsite,
      officialWebsite: event.officialWebsite || event.sourceURL,
      ticketURL: event.ticketURL,
      dataSources: [`vancouver-${this.venue.name.toLowerCase().replace(/\s+/g, '-')}`],
      lastUpdated: new Date()
    };
  }

  /**
   * Determine season based on date
   * @param {Date} date - Event date
   * @returns {string} - Season name
   */
  determineSeason(date) {
    if (!date || !(date instanceof Date)) {
      return 'Unknown';
    }
    
    const month = date.getMonth();
    
    if (month >= 2 && month <= 4) return 'Spring';
    if (month >= 5 && month <= 7) return 'Summer';
    if (month >= 8 && month <= 10) return 'Fall';
    return 'Winter';
  }
}

module.exports = new FortuneSoundClubBridge();
